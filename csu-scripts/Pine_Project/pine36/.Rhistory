(d/2*sin(2*pi*X/(N/2)))
B <- (ERD/2-((d/2)*cos(2*pi*X/(N/2))))
################################
N <- 36       # total number of spokes#
ERD <- 613    # effective rim diameter#
W <- 33.7     # width from center to flange#
d <- 63       # flange diameter#
S <- 2.4      # spoke hole diameter#
X <- 3        # no. cross (decimal allowed)#
#
A <- (d/2*sin(2*pi*X/(N/2)))#
B <- (ERD/2-((d/2)*cos(2*pi*X/(N/2))))#
#
Length <- sqrt(A^2+B^2+W^2) - S/2#
Length
(ERD/2 - ((d/2)*cos(2*pi*X/(N/2))))
ERD/2 - ((d/2)*cos(2*pi*X/(N/2)))
ERD/2 - (d/2)*cos(2*pi*X/(N/2))
B <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))
B
################################
### Spoke Length Calculator ####
################################
N <- 36       # total number of spokes#
ERD <- 613    # effective rim diameter#
W <- 33.7     # width from center to flange#
d <- 63       # flange diameter#
S <- 2.4      # spoke hole diameter#
X <- 3        # no. cross (decimal allowed)#
#
A <- d/2 * sin(2*pi*X/(N/2))#
B <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
#
#(ERD/2 - ((d/2)*cos(2*pi*X/(N/2))))#
#
Length <- sqrt(A^2+B^2+W^2) - S/2#
Length
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter#
# W = width from center to flange#
# d = flange diameter#
# S = spoke hole diameter#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   #(ERD/2 - ((d/2)*cos(2*pi*X/(N/2))))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   Length#
}#
#
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=4)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter#
# W = width from center to flange#
# d = flange diameter#
# S = spoke hole diameter#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   cat("Spoke Length is ", Length)#
}
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter#
# W = width from center to flange#
# d = flange diameter#
# S = spoke hole diameter#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   cat("Spoke Length is: ", Length)#
}#
#
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter#
# W = width from center to flange#
# d = flange diameter#
# S = spoke hole diameter#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   cat("Spoke Length is:", Length)#
}#
#
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter#
# W = width from center to flange#
# d = flange diameter#
# S = spoke hole diameter#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   cat("Spoke Length is:", Length)#
   Length#
}#
#
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter#
# W = width from center to flange#
# d = flange diameter#
# S = spoke hole diameter#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   cat("Spoke Length is:", Length, "mm")#
   #Length#
}#
#
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter#
# W = width from center to flange#
# d = flange diameter#
# S = spoke hole diameter#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   cat("Spoke Length is:", Length, "mm", sep="")#
   #Length#
}#
#
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter#
# W = width from center to flange#
# d = flange diameter#
# S = spoke hole diameter#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   cat("Spoke Length is: ", Length, "mm", sep="")#
   #Length#
}#
#
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter (mm)#
# W = width from center to flange (mm)#
# d = flange diameter (mm)#
# S = spoke hole diameter (mm)#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   cat("Spoke Length is: ", Length, "mm", sep="")#
   return(Length)#
}#
#
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter (mm)#
# W = width from center to flange (mm)#
# d = flange diameter (mm)#
# S = spoke hole diameter (mm)#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   Length#
   cat("Spoke Length is: ", Length, "mm", sep="")#
}#
#
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter (mm)#
# W = width from center to flange (mm)#
# d = flange diameter (mm)#
# S = spoke hole diameter (mm)#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   Length#
   cat("Spoke Length is: ", Length, "mm", sep="", "/n")#
}#
#
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter (mm)#
# W = width from center to flange (mm)#
# d = flange diameter (mm)#
# S = spoke hole diameter (mm)#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   Length#
   cat("Spoke Length is: ", Length, "mm", sep="", "\n")#
}#
#
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
x=spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter (mm)#
# W = width from center to flange (mm)#
# d = flange diameter (mm)#
# S = spoke hole diameter (mm)#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   Length#
   cat("Spoke Length is: ", Length, "mm", sep="", "\n")#
   Length#
}#
#
x=spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter (mm)#
# W = width from center to flange (mm)#
# d = flange diameter (mm)#
# S = spoke hole diameter (mm)#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   cat("Spoke Length is: ", Length, "mm", sep="", "\n")#
   Length#
}#
#
x=spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=3)
x
spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=2)
SL <- spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=2)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter (mm)#
# W = width from center to flange (mm)#
# d = flange diameter (mm)#
# S = spoke hole diameter (mm)#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   cat("Spoke Length = ", Length, "mm", sep="", "\n")#
   Length#
}#
#
SL <- spoke.length(N=36, ERD=613, W=33.7, d=63, S=2.4, X=2)#
SL
#
SL <- spoke.length(N=32, ERD=613, W=33.7, d=63, S=2.4, X=2)#
SL
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter (mm)#
# W = width from center to flange (mm)#
# d = flange diameter (mm)#
# S = spoke hole diameter (mm)#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   cat("Spoke Length = ", Length, "mm", sep="", "\n")#
}#
#
SL <- spoke.length(N=32, ERD=613, W=33.7, d=63, S=2.4, X=2)
SL
SL <- spoke.length(N=32, ERD=613, W=33.7, d=63, S=2.5, X=2)
SL <- spoke.length(N=32, ERD=613, W=33.7, d=63, S=2.4, X=2)
SL <- spoke.length(N=32, ERD=613, W=33.7, d=63, S=2.4, X=3)
SL <- spoke.length(N=32, ERD=613, W=33.7, d=63, S=2.5, X=3)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter (mm)#
# W = width from center to flange (mm)#
# d = flange diameter (mm)#
# S = spoke hole diameter (mm)#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   cat("Spoke Length = ", Length, "mm", sep="", "\n")#
}#
#
spoke.length(N=32, ERD=613, W=33.7, d=63, S=2.5, X=3)
################################
### Spoke Length Calculator ####
################################
# N = total number of spokes#
# ERD = effective rim diameter (mm)#
# W = width from center to flange (mm)#
# d = flange diameter (mm)#
# S = spoke hole diameter (mm)#
# X = no. cross (decimal allowed)#
#################################################
spoke.length <- function(N, ERD, W, d, S, X) {#
   x1 <- d/2 * sin(2*pi*X/(N/2))#
   x2 <- ERD/2 - (d/2) * cos(2*pi*X/(N/2))#
   Length <- sqrt(x1^2 + x2^2 + W^2) - S/2#
   cat("Spoke Length = ", Length, "mm", sep="", "\n")#
}#
#
spoke.length(N=32, ERD=613, W=33.7, d=63, S=2.5, X=2)
spoke.length(N=32, ERD=615, W=33.7, d=63, S=2.5, X=2)
spoke.length(N=32, ERD=617, W=33.7, d=63, S=2.5, X=2)
spoke.length(N=32, ERD=618, W=33.7, d=63, S=2.5, X=2)
spoke.length(N=32, ERD=613, W=33.7, d=63, S=2.5, X=2)
spoke.length(N=32, ERD=613, W=33.7, d=63, S=2.5, X=3)
spoke.length(N=32, ERD=616, W=33.7, d=63, S=2.5, X=3)
spoke.length(N=32, ERD=600, W=33.7, d=63, S=2.5, X=3)
spoke.length(N=32, ERD=610, W=33.7, d=63, S=2.5, X=3)
##############################################
# Target zones of heart rates for endurance ##
##############################################
tzone <- function(age, RHR, level) {#
   MHR <- 220 - age    # max heart rate#
   HRR <- MHR - RHR    # heart rate reserve#
   Zone <- HRR * level/100 + RHR  # target zone#
   Zone#
}#
#
tzone(age=35, RHR=60, level=90)#
tzone(age=35, RHR=60, level=60)
tzone(age=35, RHR=60, level=95)
tzone(age=35, RHR=60, level=96)
tzone(age=35, RHR=60, level=100)
tzone(age=35, RHR=60, level=9120)
tzone(age=35, RHR=60, level=120)
tzone(age=35, RHR=60, level=122)
tzone(age=35, RHR=60, level=140)
tzone(age=35, RHR=60, level=130)
sample(1:50)
sample(11:50)
########
rm(list=ls()) ###########
#########################
gear.ratio <- function(wheelsize, tyre, crank.length, crank, cassette) {#
	if (wheelsize == "700c") wheelsize <- 622#
	wheel.diameter <- wheelsize + (2 * tyre)#
	wheel.radius <- wheel.diameter / 2#
	r.ratio <- wheel.radius / crank.length#
	Ring1 <- r.ratio * min(crank) / cassette#
	Ring2 <- r.ratio * max(crank) / cassette#
	if (length(crank)==3) Ring3 <- r.ratio * crank[2] / cassette#
	gain.ratio <- cbind(Ring1, Ring2)#
	if (length(crank)==3) gain.ratio <- cbind(Ring1, Ring3, Ring2)#
	rownames(gain.ratio) <- cassette#
	colnames(gain.ratio) <- crank#
#
	### Development in cm ####
	circ <- 2 * pi * crank.length#
	development <- gain.ratio * circ / 10#
#
	### Gear Inches ####
	conversion <- 0.039370079          ### convert mm -> inches#
	wheelsize.inch <- wheel.diameter * conversion#
	Ring1 <- wheelsize.inch * min(crank) / cassette#
	Ring2 <- wheelsize.inch * max(crank) / cassette#
	if (length(crank)==3) Ring3 <- wheelsize.inch * crank[2] / cassette#
	gear.inch <- cbind(Ring1, Ring2)#
	if (length(crank)==3) gear.inch <- cbind(Ring1, Ring3, Ring2)#
	rownames(gear.inch) <- cassette#
	colnames(gear.inch) <- crank#
	Out <- list(Wheel.Size_mm = wheel.diameter,#
				Wheel.Size_in = wheelsize.inch,#
				Gain.Ratio = round(gain.ratio, 2),#
				Development_cm = round(development, 2),#
				Gear.Inches = round(gear.inch, 2))#
	Out#
} # END function()#
#
####################
### function call
gear.ratio(wheelsize="700c", tyre=23, crank.length=175, crank=50, cassette=16)
v1 <- c(34, 50)   # crank
gear.ratio(wheelsize="700c", tyre=23, crank.length=175, crank=v1, cassette=16)
gear.ratio(wheelsize="700c", tyre=23, crank.length=175, crank=c(50,50), cassette=16)
gear.ratio(wheelsize="700c", tyre=23, crank.length=170, crank=c(50,50), cassette=16)
v2 <- c(11, 12, 13, 14, 15, 17, 19, 21, 23, 26)   # cassette
gear.ratio(wheelsize="700c", tyre=23, crank.length=175, crank=v1, cassette=v2)
curve(x^2, from=-5, to=5)
curve(x^2-r^2, from=-5, to=5, r=4)
curve(x^2-r^2, from=-5, to=5, data=list(r=4))
curve(x^2-4^2, from=-5, to=5)
curve(sqrt(x^2-4^2), from=-5, to=5)
curve(sqrt(x^2-1^2), from=-5, to=5)
curve(sqrt(-x^2+1^2), from=-5, to=5)
curve(sqrt(-x^2+3^2), from=-5, to=5)
r=3; h=5; k=5
curve(sqrt(r^2-(x-h)^2)+k, from=-5, to=5, col="navy")
curve(sqrt(r^2-(x-h)^2)+k, from=0, to=10, ylim=c(0,10), col="navy")
mod(-5)
Mod(-5)
runif(1,-0.1,0.1)
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
r <- 5#
count <- 0
while (Mod(x) < r | Mod(y) < r){#
  x <- x + runif(1,-0.1,0.1)#
  y <- y + runif(1,-0.1,0.1)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
}
x <- runif(100)  dim(x) <- c(20,5)#
panel.cor1 <- function(x,y,...){    mycor<- cor(x,y)    if (mycor > 0){    points(x,y, pch = 20, col = "red",cex = 0.5)   } else {    points(x,y, pch = 20, col = "grey",cex = 0.5)   }  }#
panel.cor2 <- function(x,y,...){    mycor<- cor(x,y)    if (mycor > 0){    points(x,y, pch = 20, col = "blue",cex = 0.5)   hpts <- chull(x,y)    hpts <- c(hpts, hpts[1])    lines(x[hpts],y[hpts],col = "red")    } else {    points(x,y, pch = 20, col = "grey",cex = 0.5)   }  }
x <- runif(100)
dim(x) <- c(20,5)
panel.cor1 <- function(x,y,...){#
  mycor<- cor(x,y) #
  if (mycor > 0){ #
    points(x,y, pch = 20, col = "red",cex = 0.5)   } else { #
    points(x,y, pch = 20, col = "grey",cex = 0.5)   } #
}
#
panel.cor1 <- function(x,y,...){#
  mycor<- cor(x,y)#
  if (mycor > 0){#
    points(x,y, pch = 20, col = "red",cex = 0.5)   } else {#
    points(x,y, pch = 20, col = "grey",cex = 0.5)   }#
}
#
panel.cor1 <- function(x,y,...){#
  mycor<- cor(x,y)#
  if (mycor > 0){#
    points(x,y, pch = 20, col = "red",cex = 0.5)} else {#
    points(x,y, pch = 20, col = "grey",cex = 0.5)}#
}
panel.cor1 <- function(x,y,...){#
  mycor<- cor(x,y)#
  if (mycor > 0){#
    points(x,y, pch=20, col="red",cex=0.5)} else {#
    points(x,y, pch=20, col="grey",cex=0.5)}#
}
#
panel.cor1 <- function(x,y,...){#
  mycor<- cor(x,y)#
  if (mycor > 0){#
    points(x,y, pch=20, col="red",cex=0.5)} else {#
    points(x,y, pch=20, col="grey",cex=0.5)}#
}
  mycor<- cor(x,y)
  mycor <- cor(x,y)
panel.cor1 <- function(x,y,...){
  mycor <- cor(x,y)
  if (mycor > 0){
  if (mycor > 0){
panel.cor1 <- function(x,y,...){#
  mycor <- cor(x,y)#
  if (mycor > 0){#
    points(x,y, pch=20, col="red",cex=0.5)} else {#
    points(x,y, pch=20, col="grey",cex=0.5)}#
}
panel.cor2 <- function(x,y,...){ #
   mycor<- cor(x,y) #
   if (mycor > 0){ #
     points(x,y, pch = 20, col = "blue",cex = 0.5)   hpts <- chull(x,y) #
     hpts <- c(hpts, hpts[1]) #
     lines(x[hpts],y[hpts],col = "red") #
	} else { #
	points(x,y, pch = 20, col = "grey",cex = 0.5)   } #
}
panel.cor2 <- function(x,y,...){ #
   mycor<- cor(x,y) #
   if (mycor > 0){ #
     points(x,y, pch = 20, col = "blue",cex = 0.5); hpts <- chull(x,y) #
     hpts <- c(hpts, hpts[1]) #
     lines(x[hpts],y[hpts],col = "red") #
	} else { #
	points(x,y, pch = 20, col = "grey",cex = 0.5)   } #
}
#
panel.cor2 <- function(x,y,...){ #
   mycor<- cor(x,y) #
   if (mycor > 0){ #
     points(x,y, pch = 20, col = "blue",cex = 0.5); hpts <- chull(x,y) #
     hpts <- c(hpts, hpts[1]) #
     lines(x[hpts],y[hpts],col = "red") #
	} else { #
	points(x,y, pch=20, col="grey", cex=0.5)} #
}
#
panel.cor1 <- function(x,y,...){#
  mycor <- cor(x,y)#
  if (mycor > 0){#
    points(x,y, pch=20, col="red",cex=0.5)} else {#
    points(x,y, pch=20, col="grey",cex=0.5)}#
}
ls()
pairs(x, lower.panel = panel.cor1, upper.panel = panel.cor2)
coords <- matrix( runif(100), nc=2 )
c1 <- c2 <- 0.5
r <- 0.2
insiders <- apply(coords, 1, function(co) (c1-co[1])^2+(c2-co[2])^2 < r^2)
plot(coords)
symbols(c1, c2, circles=r, inches=FALSE, add=TRUE)
symbols(0, 0, circles = r, inches=FALSE, add=TRUE, lwd=2, col=2)
plot(vecx,vecy,type="l")#
count#
symbols(0, 0, circles = r, inches=FALSE, add=TRUE, lwd=2, col=2)
rm(list=ls()) #########################
#######################################
#r=3; h=5; k=5#
#curve(sqrt(r^2-(x-h)^2)+k, from=0, to=10, ylim=c(0,10), col="navy")#
#######################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
r <- 5#
count <- 0#
#
while (Mod(x) < r | Mod(y) < r){#
  x <- x + runif(1,-0.1,0.1)#
  y <- y + runif(1,-0.1,0.1)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
}
plot(vecx,vecy,type="l")#
symbols(0, 0, circles = r, inches=FALSE, add=TRUE, lwd=2, col=2)
symbols(0, 0, circles = r, inches=FALSE, add=TRUE, lwd=2, col=3)
symbols(0, 0, circles = r, inches=FALSE, add=TRUE, lwd=2, col=4)
symbols(0, 0, circles = r, inches=FALSE, add=TRUE, lwd=2, fg=4)
dist <- sqrt(x^2+y^2)
###################
rm(list=ls()) #########################
#######################################
#r=3; h=5; k=5#
#curve(sqrt(r^2-(x-h)^2)+k, from=0, to=10, ylim=c(0,10), col="navy")#
#######################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
r <- 5#
dist <- 0#
count <- 0#
#
while (dist <= r) {#
  x <- x + runif(1,-0.1,0.1)#
  y <- y + runif(1,-0.1,0.1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
}
plot(vecx,vecy,type="l")
plot(vecx,vecy,type="l", ylim=c(r*1.1,r*1.1), xlim=c(r*1.1,r*1.1))
plot(vecx,vecy,type="l", ylim=c(r*-1.1,r*1.1), xlim=c(r*-1.1,r*1.1))
symbols(0, 0, circles = r, inches=FALSE, add=TRUE, lwd=2, fg=2)
abline(h=r, add=TRUE)
abline(h=-r, add=TRUE)
symbols(0, 0, circles=4, inches=FALSE, add=TRUE, lwd=2, fg=2)
symbols(0, 0, circles=3, inches=FALSE, add=TRUE, lwd=2, fg=2)
symbols(0, 0, circles=5, inches=FALSE, add=TRUE, lwd=2, fg=2)
plot(vecx,vecy,type="l", ylim=c(r*-1.2,r*1.2), xlim=c(r*-1.2,r*1.2))#
symbols(0, 0, circles=r, inches=FALSE, add=TRUE, lwd=2, fg=2)
symbols(0, 0, circles=r, inches=FALSE, add=F, lwd=2, fg=2)
symbols(0, 0, circles=4, inches=FALSE, add=F, lwd=2, fg=2)
abline(h=-.5, add=TRUE); abline(v=r, add=TRUE)
abline(h=-.5, add=TRUE); abline(v=.5, add=TRUE)
require(grid)
grid.circle(0,0,5)
grid.circle(0,0,r=5)
?grid.ciccle
?grid.circle
grid.circle()
grid.circle(0,0,r=5, add=T)
grid.circle(0,0,r=5, add=TRUE)
grid.circle(xy0,r, add=TR)
grid.circle(xy0,r)
grid.circle(x,y,r)
?symbols
symbols(0, 0, circles=.5, inches=FALSE, add=F, lwd=2, fg=2)
plot(vecx,vecy,type="l", ylim=c(r*-1.2,r*1.2), xlim=c(r*-1.2,r*1.2))#
symbols(0, 0, circles=.5, inches=FALSE, add=TRUE, lwd=2, fg=2)
abline(h=-r, add=TRUE); abline(v=r, add=TRUE)
abline(h=r, add=TRUE); abline(v=r, add=TRUE)
plot(vecx,vecy,type="l", ylim=c(r*-1.2,r*1.2), xlim=c(r*-1.2,r*1.2))#
symbols(0, 0, circles=r, inches=FALSE, add=TRUE, lwd=2, fg=2)#
abline(h=r); abline(v=r)
symbols(0, 0, circles=r, inches=FALSE, add=TRUE, lwd=2, fg=2)
abline(h=r); abline(v=r)
it<-seq(0,2*pi, l=100)
xt<-r*cos(it)
yt<-r*sin(it)
points(xt,yt,type="l",col="blue")
    xt=r*cos(t)
it
xt
yt
plot(xt,yt,type="l",col="blue")
p <- seq(0, 2*pi, l=100)
points(r*cos(p), r*sin(p), type="l", lwd=2, col=2)
p
2*pi
plot(vecx,vecy,type="l", ylim=c(r*-1.2,r*1.2), xlim=c(r*-1.2,r*1.2))#
p <- seq(0, 2*pi, l=100)#
points(r*cos(p), r*sin(p), type="l", lwd=2, col=2)#
abline(h=r); abline(v=r)
plot(vecx,vecy,type="l", ylim=c(r*-1.2,r*1.2), xlim=c(r*-1.2,r*1.2))#
p <- seq(0, 2*pi, l=100)#
points(r*cos(p), r*sin(p), type="l", lwd=2, col=2)
?circle
  circ <- seq(0, 2*pi, 100)
  circ <- seq(0, 2*pi, l=100)
circ
circle <- function(r,...){#
  circ <- seq(0, 2*pi, l=100)#
  lines(r*cos(p), r*sin(p),...)#
}
plot(vecx,vecy,type="l", ylim=c(r*-1.2,r*1.2), xlim=c(r*-1.2,r*1.2))
circle(r, lwd=2, col="darkred")
circle <- function(r,...) {circ <- seq(0, 2*pi, l=100); lines(r*cos(p), r*sin(p),...)}
circle <- function(rad,...) {#
  circ <- seq(0, 2*pi, l=100); lines(rad*cos(circ), rad*sin(circ),...)#
}
#################################
rm(list=ls()) #########################
#######################################
#r=3; h=5; k=5#
#curve(sqrt(r^2-(x-h)^2)+k, from=0, to=10, ylim=c(0,10), col="navy")#
#######################################
### Function for drawing a circle or radius r#
circle <- function(rad,...) {#
  circ <- seq(0, 2*pi, l=100); lines(rad*cos(circ), rad*sin(circ),...)   }#
############################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
r <- 5#
dist <- 0#
count <- 0
while (dist <= r) {#
  x <- x + runif(1,-0.1,0.1)#
  y <- y + runif(1,-0.1,0.1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
}
plot(vecx,vecy,type="l", ylim=c(r*-1.2,r*1.2), xlim=c(r*-1.2,r*1.2))#
circle(rad=r, lwd=2, col="darkred")
count#
dist
plot(vecx, vecy, type="l", #
   ylim=c(r*-1.2,r*1.2), #
   xlim=c(r*-1.2,r*1.2), #
   xlab="", #
   ylab="")#
circle(rad=r, lwd=2, col="darkred")
#############################
### Function for drawing a circle or radius r#
circle <- function(rad,...) {#
  circ <- seq(0, 2*pi, l=100); lines(rad*cos(circ), rad*sin(circ),...)   }#
############################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000000    # diameter of sun (m)#
r <- D/2           # radius of sun (m)#
dist <- 0#
count <- 0
D <- 1391000    # diameter of sun (m)
r <- D/2           # radius of sun (m)
##########
while (dist <= r) {#
  x <- x + runif(1,-0.1,0.1)#
  y <- y + runif(1,-0.1,0.1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
}
#######
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391    # diameter of sun (Mm)#
r <- D/2           # radius of sun (Mm)#
dist <- 0#
count <- 0
############
while (dist <= r) {#
  x <- x + runif(1,-0.1,0.1)#
  y <- y + runif(1,-0.1,0.1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
}
#
d
rm(list=ls())
#########################
### Function for drawing a circle or radius r#
circle <- function(rad, ADD, ...) {#
  circ <- seq(0, 2*pi, l=100)#
  if (ADD) lines(rad*cos(circ), rad*sin(circ),...)#
  else plot(rad*cos(circ), rad*sin(circ),...)#
}
##############################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000    # diameter of sun (km)#
r <- D/2000000           # radius of sun#
dist <- 0#
count <- 0
######################
while (dist <= r) {#
  x <- x + runif(1,-0.1,0.1)#
  y <- y + runif(1,-0.1,0.1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
}
###################
### Function for drawing a circle or radius r#
circle <- function(rad, ADD, ...) {#
  circ <- seq(0, 2*pi, l=100)#
  if (ADD) lines(rad*cos(circ), rad*sin(circ),...)#
  else plot(rad*cos(circ), rad*sin(circ),...)#
}
circle(rad=r, lwd=2, col="darkred", ADD=TRUE)
circle(rad=r, lwd=2, col="darkred", ADD=F)
circle <- function(rad, ADD, ...) {#
  circ <- seq(0, 2*pi, l=100)#
  if (ADD) lines(rad*cos(circ), rad*sin(circ),...)#
  else plot(rad*cos(circ), rad*sin(circ), type="l", ylab="", xlab=""...)#
}
#
### Function for drawing a circle or radius r#
circle <- function(rad, ADD, ...) {#
  circ <- seq(0, 2*pi, l=100)#
  if (ADD) lines(rad*cos(circ), rad*sin(circ),...)#
  else plot(rad*cos(circ), rad*sin(circ), type="l", ylab="", xlab="",...)#
}
#
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun#
r <- r/500         # scale factor#
dist <- 0#
count <- 0
#
while (dist <= r) {#
  x <- x + runif(1,-0.1,0.1)#
  y <- y + runif(1,-0.1,0.1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
}
######################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun#
r <- r/500         # scale factor#
dist <- 0#
count <- 0#
######################
while (dist <= r) {#
  x <- x + runif(1,-1,1)#
  y <- y + runif(1,-1,1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
}
#
while (dist <= r) {#
  x <- x + runif(1,-1,1)#
  y <- y + runif(1,-1,1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
  if (count%%100) cat("steps =", count)#
}
#########
while (dist <= r) {#
  x <- x + runif(1,-1,1)#
  y <- y + runif(1,-1,1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
  if (count%/%100) cat("steps =", count)#
}
15%/%3
15%/%3==0
15%3==0
15%%3
15%%3==0
while (dist <= r) {#
  x <- x + runif(1,-1,1)#
  y <- y + runif(1,-1,1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
  if (count%%100==0) cat("steps =", count, "/n")#
}
##################
rm(list=ls()) #########################
#######################################
#r=3; h=5; k=5#
#curve(sqrt(r^2-(x-h)^2)+k, from=0, to=10, ylim=c(0,10), col="navy")#
#######################################
### Function for drawing a circle or radius r#
circle <- function(rad, ADD, ...) {#
  circ <- seq(0, 2*pi, l=100)#
  if (ADD) lines(rad*cos(circ), rad*sin(circ),...)#
  else plot(rad*cos(circ), rad*sin(circ), type="l", ylab="", xlab="",...)#
}#
############################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun#
r <- r/500         # scale factor#
dist <- 0#
count <- 0
while (dist <= r) {#
  x <- x + runif(1,-1,1)#
  y <- y + runif(1,-1,1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
  if (count%%100==0) cat("steps =", count, "\n")#
}
############################
rm(list=ls()) #########################
#######################################
#r=3; h=5; k=5#
#curve(sqrt(r^2-(x-h)^2)+k, from=0, to=10, ylim=c(0,10), col="navy")#
#######################################
### Function for drawing a circle or radius r#
circle <- function(rad, ADD, ...) {#
  circ <- seq(0, 2*pi, l=100)#
  if (ADD) lines(rad*cos(circ), rad*sin(circ),...)#
  else plot(rad*cos(circ), rad*sin(circ), type="l", ylab="", xlab="",...)#
}
###########################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun#
r <- r/5000         # scale factor#
dist <- 0#
count <- 0
###################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun#
r <- r/5000
D <- 1391000       # diameter of sun (km)
r <- r/5000         # scale factor
rm(list=ls()) #########################
#######################################
### Function for drawing a circle or radius r#
circle <- function(rad, ADD, ...) {#
  circ <- seq(0, 2*pi, l=100)#
  if (ADD) lines(rad*cos(circ), rad*sin(circ),...)#
  else plot(rad*cos(circ), rad*sin(circ), type="l", ylab="", xlab="", ...)#
}
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun#
r <- r/5000        # scale factor
r <- D/2           # radius of sun
################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun#
r <- r/50000        # scale factor#
dist <- 0#
count <- 0
##########################
while (dist <= r) {#
  x <- x + runif(1,-1,1)#
  y <- y + runif(1,-1,1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
  if (count%%1000==0) cat("steps =", count, "\n")#
}
####################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun#
r <- r/5000        # scale factor#
dist <- 0#
count <- 0
##################
while (dist <= r) {#
  x <- x + runif(1,-1,1)#
  y <- y + runif(1,-1,1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
  if (count%%1000==0) cat("steps =", count, "\n")#
}
circle(rad=r, lwd=2, col="darkred", ADD=FALSE)
plot(vecx, vecy, type="l", #
   ylim=c(r*-1.2,r*1.2), #
   xlim=c(r*-1.2,r*1.2), #
   xlab="", #
   ylab="")
circle(rad=r, lwd=2, col="darkred")
count
plot(vecx, vecy, type="l", #
   ylim=c(r*-1.2,r*1.2), #
   xlim=c(r*-1.2,r*1.2), #
   xlab="", #
   ylab="")#
circle(rad=r, lwd=4, col="darkred")#
count; dist; r
abline(h=v=0)
abline(h=0)
abline(h=0); abline(v=0)
#########################
rm(list=ls()) #########################
#######################################
### Function for drawing a circle of radius r#
circle <- function(rad, ADD=TRUE, ...) {#
  circ <- seq(0, 2*pi, l=100)#
  if (ADD) lines(rad*cos(circ), rad*sin(circ),...)#
  else plot(rad*cos(circ), rad*sin(circ), type="l", ylab="", xlab="", ...)#
}#
############################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun#
r <- r/5000        # scale factor#
dist <- 0#
count <- 0
plot(vecx, vecy, type="l", #
   ylim=c(r*-1.2,r*1.2), #
   xlim=c(r*-1.2,r*1.2), #
   xlab="", #
   ylab="")#
circle(rad=r, lwd=4, col="darkred")#
abline(h=0); abline(v=0)#
count; dist; r
####################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun#
f <- 5000          # scale factor#
r <- r/f#
dist <- 0#
count <- 0
r
dist
rm(list=ls()) ################################
##############################################
### Function for drawing a circle of radius r#
circle <- function(rad, ADD=TRUE, ...) {#
  circ <- seq(0, 2*pi, l=100)#
  if (ADD) lines(rad*cos(circ), rad*sin(circ),...)#
  else plot(rad*cos(circ), rad*sin(circ), type="l", ylab="", xlab="", ...)#
}
############################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun (km)#
f <- 5000          # scale factor#
r <- r/f#
dist <- 0#
count <- 0
###################
### Function for drawing a circle of radius r#
circle <- function(rad, ADD=TRUE, ...) {#
  circ <- seq(0, 2*pi, l=100)#
  if (ADD) lines(rad*cos(circ), rad*sin(circ),...)#
  else plot(rad*cos(circ), rad*sin(circ), type="l", ylab="", xlab="", ...)#
}#
############################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun (km)#
f <- 5000          # scale factor#
r <- r/f#
dist <- 0#
count <- 0
plot(vecx, vecy, type="l", #
   ylim=c(r*-1.2,r*1.2), #
   xlim=c(r*-1.2,r*1.2), #
   xlab="", #
   ylab="")#
circle(rad=r, lwd=4, col="darkred")#
abline(h=0, lty=3); abline(v=0, lty=3)
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun (km)#
f <- 5000          # scale factor#
r <- r/f#
dist <- 0#
count <- 0#
#
### Run simulation ####
while (dist <= r) {#
  x <- x + runif(1,-1,1)#
  y <- y + runif(1,-1,1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
  if (count%%1000==0) cat("steps =", count, "\n")#
}
###################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun (km)#
f <- 50000          # scale factor#
r <- r/f#
dist <- 0#
count <- 0#
#
### Run simulation ####
while (dist <= r) {#
  x <- x + runif(1,-1,1)#
  y <- y + runif(1,-1,1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
  if (count%%1000==0) cat("steps =", count, "\n")#
}
######################################
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun (km)#
f <- 5000          # scale factor#
r <- r/f#
dist <- 0#
count <- 0#
#
### Run simulation ####
while (dist <= r) {#
  x <- x + runif(1,-1,1)#
  y <- y + runif(1,-1,1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
  if (count%%1000==0) cat("steps =", count, "\n")#
}
#
### Plot simulation ####
plot(vecx, vecy, type="l", #
   ylim=c(r*-1.2,r*1.2), #
   xlim=c(r*-1.2,r*1.2), #
   xlab="", #
   ylab="")#
circle(rad=r, lwd=4, col="darkred")#
abline(h=0, lty=3); abline(v=0, lty=3)#
count; dist; r
circle <- function(rad, ADD=TRUE, ...) {#
  circ <- seq(0, 2*pi, l=100)#
  if (ADD) lines(rad*cos(circ), rad*sin(circ),...)#
  else plot(rad*cos(circ), rad*sin(circ), type="l", ylab="", xlab="", ...)#
}
x <- 0; vecx <- 0#
y <- 0; vecy <- 0#
D <- 1391000       # diameter of sun (km)#
r <- D/2           # radius of sun (km)#
f <- 5000          # scale factor#
r <- r/f           # scaled radius of sun#
dist <- 0          # initial distance from core (0,0)#
count <- 0         # counter for steps
while (dist <= r) {#
  x <- x + runif(1,-1,1)#
  y <- y + runif(1,-1,1)#
  dist <- sqrt((x-0)^2 + (y-0)^2)#
  vecx <- c(vecx, x)#
  vecy <- c(vecy, y)#
  count <- count + 1#
  if (count%%1000==0) cat("steps =", count, "\n")#
}
plot(vecx, vecy, type="l", #
   ylim=c(r*-1.2,r*1.2), #
   xlim=c(r*-1.2,r*1.2), #
   xlab="", #
   ylab="")#
circle(rad=r, lwd=4, col="darkred")
abline(h=0, lty=3); abline(v=0, lty=3)
count; dist; r
count*f
################################################
######### 36 CLASS GENETICS MODEL ##############
########### with Infection #####################
########## with Genetics 36x36 ################
############# Apr 6th 2011 #################
###########################################
#########################################
###	Stu Field ###########################
###	Department of Biology ###############
###	Colorado State University ###########
###	Fort Collins, CO 80523-1878 #########
###	sgf@colostate.edu #################
#####################################
#rm(list=ls()) #####################
#######################################################
### Find external file where all parameters located ###
#################################################################
dir <- "~/Documents/Dropbox/CSU/R-scripts/Pine Project/pine36" # <- define path here!#
setwd(dir)               # <- set working directory#
#################################################################
source(paste(dir,"pine36_Subroutines.R", sep="/"))#
source(paste(dir,"pine36_InitialPop.R", sep="/"))#
###########################################################################
pine36 <- function(                                                      ##
     Gen= 50, x1= I.pop36,                                               ##
     M= c(1, 0.152, 0.105, 0.02, 0.015), m6= 0.005,                      #   #
     R= c(1, 4, 16, 20, 50, 0),                                          ##
     Beta= 0.044,                                                        ##
     dbh.v= c(0, 0, 0, 2.05, 12.5, 37),                                  ##
     #s1 = 0.01, s2= 0.13,                                               ##
     s1= 0.99, s2= 0.87,                                                 ##
     delta= 0.15,                                                        ##
     alpha1= 0.456, alpha2= 0.0736, alpha3= 2.070,                       ##
     LAI.b= 0,                                                           ##
     Cmax= 7.5, S.cone= 46, P.find= 0.8, P.cons= 0.3, SpC= 3.7,          ##
     cf= 0.875,                                                          ##
     nBirds= 3,                                                          ##
     r.site= 1,                                                          ##
     h= 0,                                                               ##
     rho= 0.1,                                                           ##
     qpollen = FALSE,                                                    ##
     NoSeln = FALSE,                                                     ##
     plot = FALSE,                                                       ##
     outfile = FALSE,                                                    ##
     outname,                                                            ##
     out = TRUE) {                                                       ##
###########################################################################
### Gen = number of generations to run the model; default = 100          ##
### Beta default = 0.044                                                 ##
### plot = plots or no plots; default = TRUE                             ##
### out = display model output values; default = TRUE                    ##
### qpollen = pollen cloud - frequency of the recessive allele           ##
### Cost parameters = s1, s2, cf (sd2, sd3, cost to fecundity)           ##
### NoSeln = default is FALSE; for testing H-W                           ##
###########################################################################
### Storage array & vectors for results ##
#########################################stages=36;Gen=2#
stages <- length(x1)#
classes <- c("C1","C2","C3","C4","C5","C6","C1i","C2i","C3i","C4i","C5i","C6i")#
#
### overall storage of population projection ####
Popn <- array(0,dim=c(stages/3,3,Gen),dimnames=list(classes,names(I.Gtype),NULL))#
Popn[,,1]= x1              # first plane is the initial population#
#
### storage of intermediate popn following survival ### not used#
Popn.S <- array(0, dim=dim(Popn), dimnames=dimnames(Popn))#
#
### Setup storage vectors for variables of interest ####
freq.R <- freqz(I.Gtype)[1]#
freq.r <- freqz(I.Gtype)[2]#
Gtype.Sum <- matrix(NA, ncol= 3, nrow= Gen, dimnames=list(NULL,names(I.Gtype)))#
Gtype.Sum[1,] <- I.Gtype				  ### sum pop by genotype#
Pop.Total <- sum(x1[-1,])				  ### Initial PopSize (remove seeds)#
Prev.v <- sum(x1[8:12,]) / (sum(x1[-1,])) ### Initial prevalence#
SR.v = NA                                 ### storage vector Seedling Recruitment#
LAI.v = NA                                ### storage vector LAI#
r.cache.v = NA                            ### storage vector r.cache#
#
#
#########################################
#### Calculate Vital Rates ##############
#### using vitals() function ############
#########################################
M <- c(M, m6)#
S.par <- vitals(R, M)["S",]#
T.par <- vitals(R, M)["T",]#
#
####################################################
#### Set linear Parameters #########################
####################################################
### Leaf Area Calculation ###############
#########################################
LA.v <- alpha2 * (dbh.v^alpha3)#
LA.v[3]= alpha1					### Don't forget the sedondary seedlings#
#
#################
# Fitness pars ##
#################
### w[1] = R1R1#
### w[2] = R1R2#
### w[3] = R2R2#
############################
### Viability Cost - Survivorship & Transition#
#s.vec <- c(1, s1, s2, exp(-delta*(dbh.v[4:6])) )#
s.vec <- c(0, s1, s2, exp(-delta*(dbh.v[4:6])) ) # Doesn't matter which; multiplied by zero because seeds don't survive the matrix multiplication.#
#
I6 <- diag(6)#
w.hs <- diag(1 - s.vec*h)#
w.s <- diag(1 - s.vec)#
#
###########################
#### Beta parameters ######
###########################
B.vec <- c(0, rep(Beta,5))	 ### Beta is constant for all classes#
#
#####################################
#### Set up projection matrix #######
######## Linear Map Matrix ##########
#####################################
# Survivorship Matrix ###############
S <- diag(S.par) + R.diag(T.par[1:5],-1)#
#
############# Fitness Matrix ###########################
W.AA <- BlockMat(list(I6,zeros(6), zeros(6),I6), b=2)#
W.Aa <- BlockMat(list(I6,zeros(6), zeros(6),w.hs), b=2)#
W.aa <- BlockMat(list(I6,zeros(6), zeros(6),w.s), b=2)#
#
# Zeros Matrix for filling ##
Z <- zeros(stages/3)#
#
blocks <- list( W.AA, Z, Z,#
				Z, W.Aa, Z,#
				Z, Z, W.aa)#
				#
W.s <- BlockMat(blocks, b=3)#
if (NoSeln) W.s <- diag(36)   ### No selection#
#
# Beta Matrix#
B <- diag(B.vec)#
#
# Combine sub-matrices for survival#
SM12 <- BlockMat(list(S,zeros(6), zeros(6),S), b=2)#
SM36 <- BlockMat(list(SM12,Z,Z, Z,SM12,Z, Z,Z,SM12), b=3)#
#
# Combine sub-matrices for infection#
BM12 <- BlockMat(list(I6-B,zeros(6), B,I6), b=2)#
BM36 <- BlockMat(list(BM12,Z,Z, Z,BM12,Z, Z,Z,BM12), b=3)#
#
######################################################
########## Now the Loop over generations! ############
######################################################
for (n in 2:Gen) {#
	####################################
	### Reset x.vec for new iteration#
	####################################
	x.vec <- Popn[,,n-1]#
	#
	#################################
	##### LAI.x Calculation #########
	#################################
	### Projected LAI of last year's popn (x) (1 ha = 10000 m^2)#
	LAI.x <- sum(LA.v * as.vector(x.vec)) / 10000 + LAI.b#
#
	#############################
	### Determine New Seedlings:#
	#############################
	SpB <- sum(x.vec[1,]) / nBirds#
	r.cache <- 0.73 / (1 + exp((31000 - SpB)/3000)) + 0.27#
	r.cache.v[n] = r.cache					### Store & track r.cache#
	r.ALs <- 1 / (1 + exp(2*(LAI.x - 3)))#
#
	### Seedling transition (proportion seeds becoming seedlings)#
	SR <- (((1 - P.find) * (1 - P.cons)) / SpC) * r.cache * r.ALs * r.site#
	SR.v[n] = SR							### Store SR for plotting#
	New.Seedlings <- Popn[1,,n-1] * SR		### Determine number of seedlings#
#
	### Add seedlings to population#
	x.vec[2,] <- x.vec[2,] + New.Seedlings#
#
	##########################
	### Survive & transition#
	##########################
	### POST-multiplication of cost matrix W.s#
	y.vec <- (SM36 %*% W.s) %*% as.vector(x.vec)#
	#
	Popn.S[,,n]= y.vec # Matrix stores survivorship vectors at each iteration#
#
	#################################
	##### LAI.y Calculation #########
	#################################
	LAI.y <- sum(LA.v * y.vec) / 10000 + LAI.b	### LAI of this year's popn#
	LAI.v[n]= LAI.y					   ### Store and track of LAI over time#
	#
	#########################
	### Determine New Seeds:#
	#########################
	r.cones <- (0.5/(1 + exp(5*(LAI.y - 2.25))) + 0.5)#
	C.tree <- r.cones * Cmax#
#
	##################################
	### Set up matrix of Fecundities#
	##################################
	### Fecundity Matrix #############
	F.mat <- matrix(0, nrow= stages/3, ncol= 3)#
	#
	F.mat[c(5,11),]= rho * (S.cone * C.tree)#
	F.mat[c(6,12),]= S.cone * C.tree#
#
	### Fitness Matrix ####################
	W <- matrix(0, nrow=stages/3, ncol=3)#
	W[5:6,]= 1 									# no cost to uninfected genotypes#
	W[11:12,]= rep(c(1, 1-h*cf, 1-cf), each=2)  # fitness of infected gtypes#
	if (NoSeln) W[11:12,] <- 1                  # No selection#
	#
	### Hadamard product ########
	W.f <- W * F.mat#
	#
	############################################
	### convenient matrix Y of the #
	### surviving population; cols = genotypes#
	############################################
	Y <- matrix(y.vec, ncol=3)#
	#
	########################
	####### Mating #########
	########################
	### This uses Jesse's simplified code from FEScUE#
	### assumes explicitely random mating#
	### outputs matrix with next year's seeds#
	############################################
	if (!qpollen) Seeds <- mating36(Y, W.f)#
	if (qpollen>0) Seeds <- mating36p(Y, W.f, qpollen) #fixed pollen cloud mating#
	#
	##########################################
	#### Add newborns to population  #########
	##########################################
	y.vec <- as.vector(Y + Seeds)		### Add seeds to population in the Fall#
#
	##############################
	### Infect the population ####
	##############################
	Popn[,,n]= BM36 %*% y.vec			### Infect in Fall (last operation)#
#
	####################################################
	########### OUTPUTS OF INTEREST ####################
	####################################################
	Gtypes <- apply(Popn[-1,,n], 2, sum) 	### sum the cols (Gtypes); #
	                                        ### put [-1,x,n] to remove seeds#
	Gtype.Sum[n,] <- Gtypes#
	freq.R[n] <- freqz(Gtypes)[1]			### Calc p#
	freq.r[n] <- freqz(Gtypes)[2]			### Calc q#
	Pop.Total[n]= sum(Popn[-1,,n])			### remove seeds#
	Prev.v[n]= ifelse(h==0, #
	                  sum(Popn[8:12,3,n])/(sum(Popn[-1,,n])), #
	                  sum(Popn[8:12,2:3,n])/(sum(Popn[-1,,n])))#
}  # END OF LOOP#
#
#
#
##############################
### POST-PROCESS ANALYSIS ####
##############################
# function for calculating # dead trees (not used in pine36)#
# DeadPine <- DeadTrees36(Popn, B=Beta, w=w.s)#
#########################
# Post-process Lambda #
# Proportional Growth#
Lambda <- LambdaGrow(Pop.Total)   # Total population Lambda#
Lambda2 <- LambdaGrow2(Gtype.Sum) # Lambda by genotype#
#
#
##########################################
### Convert Solutions & Export to CSV ####
##########################################
if (outfile) {#
  for (fx in 1:Gen) {#
    if (fx==1) full2x2 <- as.vector(Popn[,,1])#
    else full2x2 <- rbind(full2x2, as.vector(Popn[,,fx]))#
    if (fx==Gen) {rownames(full2x2) <- paste("t",1:Gen,sep="")#
    	          colnames(full2x2) <- paste("Class_",1:stages,sep="")}#
  }#
  write.csv(full2x2, file= paste(outname,"_FullSoln_",Sys.Date(),".csv", sep=""))#
}#
#
#
##################################################
##################################################
####### Plot variables of interest ###############
##################################################
##################################################
if (plot)   {#
   par(mfrow=c(2,3))#
   plot(1:Gen, Pop.Total, 'l', #
      xlim=c(0,Gen), #
      xlab="Years", #
      main="Total Population", #
      ylab="Total Whitebark Population (no seeds)", #
      col='navy', lwd=2); grid()#
   plot(1:Gen, freq.R, #
      xlab="Years", #
      main="R1 Allele", #
      ylab="p", #
      col="darkgreen"); grid()#
   plot(1:Gen, Prev.v, 'l', #
      col='dark red', #
      lwd=2, #
      xlab="Years", #
      main="Rust Prevalence", #
      ylab="Proportion infected individuals"); grid()#
   plot(1:(Gen-1), LAI.v[2:Gen], #
      xlab="Years", #
      main="Post-Survival Leaf Area Index", #
      ylab="LAI.y"); grid()#
   plot(1:(Gen-1), SR.v[2:Gen], #
      xlab="Years", #
      main="Germination Rate", #
      ylab="SR"); grid()#
   plot(1:(Gen-1), r.cache.v[2:Gen], #
      xlab="Years", #
      main="r.cache", #
      ylab="r.cache"); grid()#
}#
#############################################################################
   Out <- list(                        # Create output list#
      Final.Popn = Popn[,,Gen],        # Final Solution#
      Gtypes = Gtype.Sum,              # Final Solution by Genotype#
      Final.Sum = Pop.Total[Gen],      # Total Popn#
      Pop.Totals = Pop.Total,          # Total Popn vector over time#
      R2 = unname(freq.r[Gen]),        # Frequency of 'q' allele final time (t)#
      Germ.rate = SR.v,                # Vector of Germination rates#
      r.cones = r.cones,               # r.cones in final time (t)#
      Final.Seeds = Seeds,             # Seeds produced in final time (t)#
      LAIy = LAI.v,                    # LAI.y in final time (t)#
      Prevalence = Prev.v,             # Vector of disease prevalence#
      #Dead.Pines = DeadPine,          # Not used#
      Delta.Grow = Lambda,             # Lambda = x(t) / x(t-1)#
      Delta.Grow.Gtype = Lambda2,      # Lambda by Genotype#
      FullSolution = Popn)             # ALL Solutions by Generation#
##############################################################################   #
   if (out) Out                        # print 'Out'#
#
}  # END OF pine36#
#
#####################
### Run pine36 ######
#####################
pine36(Gen=500, outfile=TRUE, outname="Run1", out=FALSE)
